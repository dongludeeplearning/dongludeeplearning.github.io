<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style>
  :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --panel2:#0c1430;
      --text:#e8ecff;
      --muted:#aeb7e6;
      --border:rgba(255,255,255,.10);
      --accent:#7aa2ff;
      --accent2:#8bffcf;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  }
  body {
    background: transparent;
    background-color: var(--bg);
    color: var(--text);
    font-family: var(--sans);
    margin: 0;
    padding: 16px;
    box-sizing: border-box;
  }
  ::-webkit-scrollbar { width: 8px; height: 8px; }
  ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
  ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
  ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }
</style>
<script>
function toggleLang(btn) {
  const container = btn.closest('div');
  const enElements = container.querySelectorAll('.lang-en');
  const zhElements = container.querySelectorAll('.lang-zh');

  enElements.forEach(el => {
    el.style.display = (el.style.display === 'none') ? 'block' : 'none';
  });

  zhElements.forEach(el => {
    el.style.display = (el.style.display === 'none') ? 'block' : 'none';
  });
}
function openLocalPdf(filename) {
  window.open('pdfs/' + filename, '_blank');
}
function delLocalPdf(filename) {
  if (confirm('Delete local PDF file: ' + filename + '? Note: This requires server environment to actually delete files.')) {
    alert('Delete function needs to be implemented on the server side.');
  }
}
</script>
</head>
<body>
<section style="max-width:980px;margin:0 auto;">
    <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
      <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
      <div style="font-family:ui-monospace,Menlo,Consolas,monospace;color:rgba(232,236,255,.7);font-size:12px;">
        Paper Digest â€¢ ArXiv 2023
      </div>
      <h1 style="margin:6px 0 0;font-size:22px;line-height:1.25;">Toolformer: Language Models Can Teach Themselves to Use Tools</h1>
      <div style="margin-top:6px;color:rgba(232,236,255,.6);font-size:12px;line-height:1.5;">
        Timo Schick, Jane Dwivedi-Yu, Roberto DessÃ¬, Roberta Raileanu, Maria Lomeli, Luke Zettlemoyer, Nicola Cancedda, Thomas Scialom<br>
        <span style="opacity:0.8">Meta AI Research, Universitat Pompeu Fabra</span>
      </div>
      <div style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,.08);color:rgba(232,236,255,.75);font-size:13px;line-height:1.6;">
        <div class="lang-en">
            <b>One-Sentence Problem:</b> How can language models autonomously learn to use external tools via simple APIs in a self-supervised manner, enabling them to overcome inherent limitations like factual lookup, mathematical calculation, and multilingual understanding without requiring large amounts of human annotations?
        </div>
        <div class="lang-zh" style="display:none">
            <b>ä¸€å¥è¯é—®é¢˜ï¼š</b>å¦‚ä½•è®©è¯­è¨€æ¨¡å‹é€šè¿‡ç®€å•çš„APIä»¥è‡ªç›‘ç£çš„æ–¹å¼è‡ªä¸»å­¦ä¹ ä½¿ç”¨å¤–éƒ¨å·¥å…·ï¼Œä½¿å…¶èƒ½å¤Ÿå…‹æœå›ºæœ‰çš„å±€é™æ€§ï¼Œå¦‚äº‹å®æŸ¥æ‰¾ã€æ•°å­¦è®¡ç®—å’Œå¤šè¯­è¨€ç†è§£ï¼Œè€Œæ— éœ€å¤§é‡äººå·¥æ ‡æ³¨ï¼Ÿ
        </div>
      </div>
    </div>

    <div style="display:grid;grid-template-columns:1fr;gap:14px;margin-top:14px;">
      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Contributionsï¼ˆè´¡çŒ®ï¼‰</h2>
        <ul style="margin:0;padding-left:18px;color:rgba(232,236,255,.80);line-height:1.65;">
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Self-Supervised Tool Learning:</b> Introduced Toolformer, the first model that learns to use external tools autonomously through self-supervised learning, requiring only a handful of API demonstrations without extensive human annotations.</div>
            <div class="lang-zh" style="display:none"><b>è‡ªç›‘ç£å·¥å…·å­¦ä¹ ï¼š</b>å¼•å…¥äº†Toolformerï¼Œè¿™æ˜¯ç¬¬ä¸€ä¸ªé€šè¿‡è‡ªç›‘ç£å­¦ä¹ è‡ªä¸»å­¦ä¹ ä½¿ç”¨å¤–éƒ¨å·¥å…·çš„æ¨¡å‹ï¼Œåªéœ€è¦å°‘é‡çš„APIæ¼”ç¤ºï¼Œæ— éœ€å¤§é‡äººå·¥æ ‡æ³¨ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Comprehensive Tool Integration:</b> Successfully integrated five diverse tools (calculator, QA system, Wikipedia search, machine translation, and calendar) that address major LM limitations including arithmetic, factual knowledge, multilingual understanding, and temporal awareness.</div>
            <div class="lang-zh" style="display:none"><b>å…¨é¢å·¥å…·é›†æˆï¼š</b>æˆåŠŸé›†æˆäº†äº”ç§å¤šæ ·åŒ–çš„å·¥å…·ï¼ˆè®¡ç®—å™¨ã€é—®ç­”ç³»ç»Ÿã€ç»´åŸºç™¾ç§‘æœç´¢ã€æœºå™¨ç¿»è¯‘å’Œæ—¥å†ï¼‰ï¼Œè¿™äº›å·¥å…·è§£å†³äº†LMçš„ä¸»è¦å±€é™æ€§ï¼ŒåŒ…æ‹¬ç®—æœ¯ã€äº‹å®çŸ¥è¯†ã€å¤šè¯­è¨€ç†è§£å’Œæ—¶é—´æ„è¯†ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>State-of-the-Art Performance:</b> Achieved substantial zero-shot performance improvements on various downstream tasks, with a 6.7B parameter GPT-J model outperforming much larger models like GPT-3 (175B) on math, QA, and fact-checking benchmarks.</div>
            <div class="lang-zh" style="display:none"><b>æœ€å…ˆè¿›æ€§èƒ½ï¼š</b>åœ¨å„ç§ä¸‹æ¸¸ä»»åŠ¡ä¸Šå®ç°äº†æ˜¾è‘—çš„é›¶-shotæ€§èƒ½æ”¹è¿›ï¼Œä¸€ä¸ª67äº¿å‚æ•°çš„GPT-Jæ¨¡å‹åœ¨æ•°å­¦ã€é—®ç­”å’Œäº‹å®æ£€æŸ¥åŸºå‡†ä¸Šè¶…è¿‡äº†æ›´å¤§çš„æ¨¡å‹å¦‚GPT-3ï¼ˆ1750äº¿ï¼‰ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Autonomous Tool Selection:</b> Developed a framework where LMs autonomously decide when and which tools to use, learning to call APIs in the most appropriate contexts without explicit human instructions.</div>
            <div class="lang-zh" style="display:none"><b>è‡ªä¸»å·¥å…·é€‰æ‹©ï¼š</b>å¼€å‘äº†ä¸€ä¸ªæ¡†æ¶ï¼Œå…¶ä¸­LMè‡ªä¸»å†³å®šä½•æ—¶ä»¥åŠä½¿ç”¨å“ªäº›å·¥å…·ï¼Œåœ¨æœ€åˆé€‚çš„ä¸Šä¸‹æ–‡ä¸­å­¦ä¹ è°ƒç”¨APIï¼Œè€Œæ— éœ€æ˜ç¡®çš„æŒ‡ç¤ºã€‚</div>
          </li>
        </ul>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Challengesï¼ˆæŒ‘æˆ˜ï¼‰</h2>
        <ul style="margin:0;padding-left:18px;color:rgba(232,236,255,.80);line-height:1.65;">
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Annotation Cost:</b> Traditional tool-augmented LMs require extensive human annotations to learn when and how to use tools, making the approach expensive and difficult to scale across many tools and domains.</div>
            <div class="lang-zh" style="display:none"><b>æ ‡æ³¨æˆæœ¬ï¼š</b>ä¼ ç»Ÿçš„å·¥å…·å¢å¼ºLMéœ€è¦å¤§é‡äººå·¥æ ‡æ³¨æ¥å­¦ä¹ ä½•æ—¶ä»¥åŠå¦‚ä½•ä½¿ç”¨å·¥å…·ï¼Œä½¿å¾—è¿™ç§æ–¹æ³•æ˜‚è´µä¸”éš¾ä»¥æ‰©å±•åˆ°è®¸å¤šå·¥å…·å’Œé¢†åŸŸã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Task-Specific Adaptation:</b> Existing approaches often limit tool use to specific tasks or require manual prompt engineering for each use case, preventing models from autonomously generalizing tool use across diverse scenarios.</div>
            <div class="lang-zh" style="display:none"><b>ä»»åŠ¡ç‰¹å®šé€‚åº”ï¼š</b>ç°æœ‰æ–¹æ³•é€šå¸¸å°†å·¥å…·ä½¿ç”¨é™åˆ¶åœ¨ç‰¹å®šä»»åŠ¡ä¸­ï¼Œæˆ–éœ€è¦ä¸ºæ¯ä¸ªç”¨ä¾‹è¿›è¡Œæ‰‹åŠ¨æç¤ºå·¥ç¨‹ï¼Œé˜»æ­¢æ¨¡å‹è‡ªä¸»åœ°å°†å·¥å…·ä½¿ç”¨æ³›åŒ–åˆ°å¤šæ ·åŒ–åœºæ™¯ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Tool Integration Complexity:</b> Seamlessly integrating external tools into LM architectures requires handling text-to-API conversions, result interpretation, and maintaining coherence in generated text across tool calls.</div>
            <div class="lang-zh" style="display:none"><b>å·¥å…·é›†æˆå¤æ‚æ€§ï¼š</b>å°†å¤–éƒ¨å·¥å…·æ— ç¼é›†æˆåˆ°LMæ¶æ„ä¸­éœ€è¦å¤„ç†æ–‡æœ¬åˆ°APIçš„è½¬æ¢ã€ç»“æœè§£é‡Šä»¥åŠåœ¨å·¥å…·è°ƒç”¨ä¸­ä¿æŒç”Ÿæˆæ–‡æœ¬çš„è¿è´¯æ€§ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Quality Control:</b> Ensuring that tool calls are appropriate and results are correctly incorporated requires mechanisms to filter out unhelpful or incorrect API usages without human supervision.</div>
            <div class="lang-zh" style="display:none"><b>è´¨é‡æ§åˆ¶ï¼š</b>ç¡®ä¿å·¥å…·è°ƒç”¨é€‚å½“ä¸”ç»“æœæ­£ç¡®çº³å…¥éœ€è¦æœºåˆ¶æ¥è¿‡æ»¤æ‰æ— å¸®åŠ©æˆ–ä¸æ­£ç¡®çš„APIä½¿ç”¨ï¼Œè€Œæ— éœ€äººå·¥ç›‘ç£ã€‚</div>
          </li>
        </ul>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Methodï¼ˆæ–¹æ³•ï¼‰</h2>
        <div style="margin:0;padding-left:18px;color:rgba(232,236,255,.80);line-height:1.65;">
          <div class="lang-en">
            <p>Toolformer learns to use tools through a self-supervised approach that augments language modeling datasets with API calls:</p>
            <ol style="margin:8px 0;">
                <li style="margin-bottom:6px;"><b>API Call Representation:</b> Represent tool calls as text sequences using special tokens ([API], [/API], ->) to seamlessly integrate with LM tokenization, allowing models to learn tool usage patterns.</li>
                <li style="margin-bottom:6px;"><b>Self-Supervised Annotation:</b> Use LM's in-context learning to sample potential API calls across a large language modeling dataset, requiring only a few demonstration examples per tool.</li>
                <li style="margin-bottom:6px;"><b>Quality Filtering:</b> Execute sampled API calls and filter them based on whether they reduce perplexity when predicting future tokens, ensuring only helpful tool usages are retained.</li>
                <li style="margin-bottom:6px;"><b>Model Finetuning:</b> Finetune the LM on the augmented dataset containing both original text and filtered API calls, enabling autonomous tool selection and usage during inference.</li>
                <li style="margin-bottom:6px;"><b>Inference with Tools:</b> During generation, interrupt decoding when API tokens are predicted, execute the corresponding tool, and continue generation with the results.</li>
            </ol>
          </div>
          <div class="lang-zh" style="display: none;">
            <p>Toolformeré€šè¿‡è‡ªç›‘ç£æ–¹æ³•å­¦ä¹ ä½¿ç”¨å·¥å…·ï¼Œè¯¥æ–¹æ³•ä½¿ç”¨APIè°ƒç”¨å¢å¼ºè¯­è¨€å»ºæ¨¡æ•°æ®é›†ï¼š</p>
            <ol style="margin:8px 0;">
                <li style="margin-bottom:6px;"><b>APIè°ƒç”¨è¡¨ç¤ºï¼š</b>ä½¿ç”¨ç‰¹æ®Šæ ‡è®°ï¼ˆ[API]ã€[/API]ã€->ï¼‰å°†å·¥å…·è°ƒç”¨è¡¨ç¤ºä¸ºæ–‡æœ¬åºåˆ—ï¼Œä»¥æ— ç¼é›†æˆLMåˆ†è¯åŒ–ï¼Œå…è®¸æ¨¡å‹å­¦ä¹ å·¥å…·ä½¿ç”¨æ¨¡å¼ã€‚</li>
                <li style="margin-bottom:6px;"><b>è‡ªç›‘ç£æ ‡æ³¨ï¼š</b>ä½¿ç”¨LMçš„ä¸Šä¸‹æ–‡å­¦ä¹ æ¥å¯¹å¤§å‹è¯­è¨€å»ºæ¨¡æ•°æ®é›†é‡‡æ ·æ½œåœ¨çš„APIè°ƒç”¨ï¼Œæ¯ä¸ªå·¥å…·åªéœ€è¦å‡ ä¸ªæ¼”ç¤ºç¤ºä¾‹ã€‚</li>
                <li style="margin-bottom:6px;"><b>è´¨é‡è¿‡æ»¤ï¼š</b>æ‰§è¡Œé‡‡æ ·çš„APIè°ƒç”¨ï¼Œå¹¶æ ¹æ®å®ƒä»¬æ˜¯å¦åœ¨é¢„æµ‹æœªæ¥æ ‡è®°æ—¶å‡å°‘å›°æƒ‘åº¦æ¥è¿‡æ»¤å®ƒä»¬ï¼Œç¡®ä¿åªä¿ç•™æœ‰å¸®åŠ©çš„å·¥å…·ä½¿ç”¨ã€‚</li>
                <li style="margin-bottom:6px;"><b>æ¨¡å‹å¾®è°ƒï¼š</b>åœ¨åŒ…å«åŸå§‹æ–‡æœ¬å’Œè¿‡æ»¤APIè°ƒç”¨çš„å¢å¼ºæ•°æ®é›†ä¸Šå¾®è°ƒLMï¼Œä½¿å…¶èƒ½å¤Ÿåœ¨æ¨ç†è¿‡ç¨‹ä¸­è‡ªä¸»é€‰æ‹©å’Œä½¿ç”¨å·¥å…·ã€‚</li>
                <li style="margin-bottom:6px;"><b>å¸¦å·¥å…·çš„æ¨ç†ï¼š</b>åœ¨ç”Ÿæˆè¿‡ç¨‹ä¸­ï¼Œå½“é¢„æµ‹å‡ºAPIæ ‡è®°æ—¶ä¸­æ–­è§£ç ï¼Œæ‰§è¡Œç›¸åº”çš„å·¥å…·ï¼Œå¹¶ä½¿ç”¨ç»“æœç»§ç»­ç”Ÿæˆã€‚</li>
            </ol>
          </div>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10)">
        <h2 style="margin:0 0 8px;font-size:16px;">Intro Figureï¼ˆå¼•è¨€å›¾ï¼‰</h2>
        <div style="border-radius:14px; overflow:hidden;">
            <img src="Figures/toolformer_intro.png" style="width:100%; height:auto; display:block; border-radius:8px;" alt="Intro Figure" />
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10)">
        <h2 style="margin:0 0 8px;font-size:16px;">Overview Figureï¼ˆç¤ºæ„å›¾ï¼‰</h2>
        <div style="border:1px solid rgba(255,255,255,.18);border-radius:14px;padding:16px;color:rgba(232,236,255,.65);line-height:1.6;">
            <img src="Figures/toolformer_overview.png" style="width:100%; height:auto; display:block; border-radius:8px;" alt="Overview Figure" />
            <p>Toolformer learns to use tools through self-supervised API call annotation and quality filtering, enabling autonomous tool selection for improved LM capabilities.</p>
            <p>Note: The approach achieves state-of-the-art zero-shot performance, with Toolformer (6.7B) outperforming GPT-3 (175B) on math, QA, and fact-checking tasks by learning when and how to call external tools.</p>

            <div style="margin-top:12px; display:flex; gap:10px; justify-content:flex-end;">
                 <button onclick="openLocalPdf('arxiv_toolformer.pdf')" style="background:rgba(139,255,207,0.1); border:1px solid rgba(139,255,207,0.3); color:#8bffcf; padding:6px 12px; border-radius:8px; cursor:pointer; font-size:12px;">ğŸ“‚ Open Local PDF</button>
                 <button onclick="delLocalPdf('arxiv_toolformer.pdf')" style="background:rgba(255,100,100,0.1); border:1px solid rgba(255,100,100,0.3); color:#ff6464; padding:6px 12px; border-radius:8px; cursor:pointer; font-size:12px;">ğŸ—‘ï¸ Del Local PDF</button>
            </div>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Discussionï¼ˆè®¨è®ºï¼‰</h2>
        <h3 style="margin:12px 0 6px;font-size:14px;color:#8bffcf;">Why it Works?</h3>
        <div style="color:rgba(232,236,255,.80);line-height:1.65;">
          <div class="lang-en">
            <p>Toolformer's self-supervised approach succeeds by leveraging the inherent capabilities of large language models:</p>
            <ul style="margin:8px 0;">
                <li style="margin-bottom:6px;"><b>Exploiting In-Context Learning:</b> Large LMs can learn tool usage patterns from just a few demonstrations, using their understanding of language to generate appropriate API calls without extensive training data.</li>
                <li style="margin-bottom:6px;"><b>Quality-Driven Learning:</b> The perplexity-based filtering mechanism ensures that only API calls that genuinely help with text completion are retained, creating a high-quality training signal from self-supervision.</li>
                <li style="margin-bottom:6px;"><b>Seamless Integration:</b> By representing API calls as text sequences with special tokens, the approach maintains compatibility with existing LM architectures while enabling tool use to be learned like any other language pattern.</li>
                <li style="margin-bottom:6px;"><b>Autonomous Decision Making:</b> Through finetuning on filtered API calls, models learn not just how to use tools, but when to use them, resulting in contextually appropriate tool selection without explicit rules.</li>
                <li style="margin-bottom:6px;"><b>Preserved Generalization:</b> Since the augmented dataset contains the original training data plus API calls, models maintain their core language modeling capabilities while gaining tool-using abilities.</li>
            </ul>
          </div>
          <div class="lang-zh" style="display:none">
            <p>Toolformerçš„è‡ªç›‘ç£æ–¹æ³•é€šè¿‡åˆ©ç”¨å¤§å‹è¯­è¨€æ¨¡å‹çš„å›ºæœ‰èƒ½åŠ›è€ŒæˆåŠŸï¼š</p>
            <ul style="margin:8px 0;">
                <li style="margin-bottom:6px;"><b>åˆ©ç”¨ä¸Šä¸‹æ–‡å­¦ä¹ ï¼š</b>å¤§å‹LMå¯ä»¥ä»å°‘é‡æ¼”ç¤ºä¸­å­¦ä¹ å·¥å…·ä½¿ç”¨æ¨¡å¼ï¼Œä½¿ç”¨å®ƒä»¬å¯¹è¯­è¨€çš„ç†è§£æ¥ç”Ÿæˆé€‚å½“çš„APIè°ƒç”¨ï¼Œè€Œæ— éœ€å¤§é‡è®­ç»ƒæ•°æ®ã€‚</li>
                <li style="margin-bottom:6px;"><b>è´¨é‡é©±åŠ¨å­¦ä¹ ï¼š</b>åŸºäºå›°æƒ‘åº¦çš„è¿‡æ»¤æœºåˆ¶ç¡®ä¿åªæœ‰çœŸæ­£æœ‰åŠ©äºæ–‡æœ¬å®Œæˆçš„APIè°ƒç”¨è¢«ä¿ç•™ï¼Œä»è‡ªç›‘ç£ä¸­åˆ›å»ºé«˜è´¨é‡çš„è®­ç»ƒä¿¡å·ã€‚</li>
                <li style="margin-bottom:6px;"><b>æ— ç¼é›†æˆï¼š</b>é€šè¿‡ä½¿ç”¨ç‰¹æ®Šæ ‡è®°å°†APIè°ƒç”¨è¡¨ç¤ºä¸ºæ–‡æœ¬åºåˆ—ï¼Œè¯¥æ–¹æ³•ä¿æŒä¸ç°æœ‰LMæ¶æ„çš„å…¼å®¹æ€§ï¼ŒåŒæ—¶ä½¿å·¥å…·ä½¿ç”¨èƒ½å¤Ÿåƒä»»ä½•å…¶ä»–è¯­è¨€æ¨¡å¼ä¸€æ ·è¢«å­¦ä¹ ã€‚</li>
                <li style="margin-bottom:6px;"><b>è‡ªä¸»å†³ç­–ï¼š</b>é€šè¿‡åœ¨è¿‡æ»¤çš„APIè°ƒç”¨ä¸Šå¾®è°ƒï¼Œæ¨¡å‹ä¸ä»…å­¦ä¹ å¦‚ä½•ä½¿ç”¨å·¥å…·ï¼Œè¿˜å­¦ä¹ ä½•æ—¶ä½¿ç”¨å®ƒä»¬ï¼Œå¯¼è‡´åœ¨æ²¡æœ‰æ˜ç¡®è§„åˆ™çš„æƒ…å†µä¸‹è¿›è¡Œä¸Šä¸‹æ–‡åˆé€‚çš„å·¥å…·é€‰æ‹©ã€‚</li>
                <li style="margin-bottom:6px;"><b>ä¿ç•™æ³›åŒ–ï¼š</b>ç”±äºå¢å¼ºæ•°æ®é›†åŒ…å«åŸå§‹è®­ç»ƒæ•°æ®åŠ ä¸ŠAPIè°ƒç”¨ï¼Œæ¨¡å‹ä¿æŒå…¶æ ¸å¿ƒè¯­è¨€å»ºæ¨¡èƒ½åŠ›ï¼ŒåŒæ—¶è·å¾—ä½¿ç”¨å·¥å…·çš„èƒ½åŠ›ã€‚</li>
            </ul>
          </div>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Conclusionï¼ˆç»“è®ºï¼‰</h2>
        <div style="color:rgba(232,236,255,.80);line-height:1.65;">
          <div class="lang-en">
            <p>This groundbreaking work introduces Toolformer, a transformative approach to equipping language models with external tools through self-supervised learning. By enabling LMs to autonomously discover and learn tool usage patterns from minimal demonstrations, Toolformer overcomes the fundamental limitations of traditional language models in areas like mathematical reasoning, factual knowledge, and multilingual understanding. The self-supervised framework, which annotates language modeling datasets with API calls and filters them based on their utility for text completion, represents a significant advancement over previous tool-augmented approaches that required extensive human annotations. Experimental results demonstrate that Toolformer, based on a 6.7B parameter GPT-J model, achieves zero-shot performance competitive with much larger models like GPT-3 (175B), particularly excelling on tasks requiring arithmetic, question answering, and temporal reasoning. This work establishes a new paradigm for tool integration in language models, where models can teach themselves to use tools without explicit supervision, opening avenues for more capable and versatile AI systems. The approach's success suggests that self-supervised tool learning could become a cornerstone of future LM development, enabling models to overcome their inherent limitations by intelligently leveraging external resources while maintaining their core language understanding capabilities.</p>
          </div>
          <div class="lang-zh" style="display:none">
            <p>è¿™é¡¹å¼€åˆ›æ€§å·¥ä½œå¼•å…¥äº†Toolformerï¼Œè¿™æ˜¯ä¸€ç§é€šè¿‡è‡ªç›‘ç£å­¦ä¹ ä¸ºè¯­è¨€æ¨¡å‹é…å¤‡å¤–éƒ¨å·¥å…·çš„å˜é©æ€§æ–¹æ³•ã€‚é€šè¿‡ä½¿LMèƒ½å¤Ÿä»æœ€å°‘çš„æ¼”ç¤ºä¸­è‡ªä¸»å‘ç°å’Œå­¦ä¹ å·¥å…·ä½¿ç”¨æ¨¡å¼ï¼ŒToolformerå…‹æœäº†ä¼ ç»Ÿè¯­è¨€æ¨¡å‹åœ¨æ•°å­¦æ¨ç†ã€äº‹å®çŸ¥è¯†å’Œå¤šè¯­è¨€ç†è§£ç­‰é¢†åŸŸçš„æ ¹æœ¬å±€é™æ€§ã€‚è‡ªç›‘ç£æ¡†æ¶é€šè¿‡APIè°ƒç”¨æ ‡æ³¨è¯­è¨€å»ºæ¨¡æ•°æ®é›†å¹¶åŸºäºå®ƒä»¬å¯¹æ–‡æœ¬å®Œæˆçš„æ•ˆç”¨è¿›è¡Œè¿‡æ»¤ï¼Œä»£è¡¨äº†ç›¸å¯¹äºéœ€è¦å¤§é‡äººå·¥æ ‡æ³¨çš„ä»¥å‰å·¥å…·å¢å¼ºæ–¹æ³•çš„é‡å¤§è¿›æ­¥ã€‚å®éªŒç»“æœè¡¨æ˜ï¼ŒåŸºäº67äº¿å‚æ•°GPT-Jæ¨¡å‹çš„Toolformeråœ¨ç®—æœ¯ã€é—®ç­”å’Œæ—¶é—´æ¨ç†ç­‰éœ€è¦ä»»åŠ¡ä¸Šå®ç°äº†ä¸æ›´å¤§æ¨¡å‹å¦‚GPT-3ï¼ˆ1750äº¿ï¼‰ç«äº‰çš„é›¶-shotæ€§èƒ½ã€‚è¿™é¡¹å·¥ä½œä¸ºè¯­è¨€æ¨¡å‹ä¸­çš„å·¥å…·é›†æˆå»ºç«‹äº†æ–°èŒƒå¼ï¼Œå…¶ä¸­æ¨¡å‹å¯ä»¥åœ¨æ²¡æœ‰æ˜ç¡®ç›‘ç£çš„æƒ…å†µä¸‹è‡ªå­¦ä½¿ç”¨å·¥å…·ï¼Œä¸ºæ›´å¼ºå¤§å’Œå¤šåŠŸèƒ½çš„AIç³»ç»Ÿå¼€è¾Ÿé€”å¾„ã€‚è¯¥æ–¹æ³•çš„æˆåŠŸè¡¨æ˜ï¼Œè‡ªç›‘ç£å·¥å…·å­¦ä¹ å¯èƒ½æˆä¸ºæœªæ¥LMå¼€å‘çš„åŸºç¡€ï¼Œä½¿æ¨¡å‹èƒ½å¤Ÿé€šè¿‡æ™ºèƒ½åˆ©ç”¨å¤–éƒ¨èµ„æºæ¥å…‹æœå…¶å›ºæœ‰é™åˆ¶ï¼ŒåŒæ—¶ä¿æŒå…¶æ ¸å¿ƒè¯­è¨€ç†è§£èƒ½åŠ›ã€‚</p>
          </div>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10)">
        <h2 style="margin:0 0 8px;font-size:16px;">Official Code</h2>
        <div style="color:rgba(232,236,255,.80);line-height:1.65;">
          <p><b>ArXiv:</b> <a href="https://arxiv.org/abs/2302.04761" target="_blank" style="color:#8bffcf;">2302.04761</a></p>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10)">
        <h2 style="margin:0 0 8px;font-size:16px;">Core Code Implementationï¼ˆæ ¸å¿ƒä»£ç ï¼‰</h2>
        <div style="background:rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.1); border-radius:8px; padding:12px; font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; color:#8bffcf; margin:8px 0; overflow-x:auto;">
# Toolformer Self-Supervised Tool Learning Implementation<br>
<br>
// API Call Representation and Execution<br>
<span style="color:#569cd6;">class</span> <span style="color:#dcdcaa;">ToolAPI</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;"""Base class for external tool APIs"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">def</span> <span style="color:#dcdcaa;">__init__</span>(self, name):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.name = name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">def</span> <span style="color:#dcdcaa;">call</span>(self, query):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Execute API call and return text result"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">pass</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">def</span> <span style="color:#dcdcaa;">format_call</span>(self, query):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Format API call as text: [API]name(query)[/API]"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">return</span> <span style="color:#ce9178;">f"[API]{self.name}({query})[/API]"</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">def</span> <span style="color:#dcdcaa;">format_result</span>(self, query, result):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Format API call with result: [API]name(query)->result[/API]"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">return</span> <span style="color:#ce9178;">f"[API]{self.name}({query})->{result}[/API]"</span><br>
<br>
// Toolformer Training Pipeline<br>
<span style="color:#569cd6;">class</span> <span style="color:#dcdcaa;">ToolformerTrainer</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;"""Self-supervised training for tool-augmented language models"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">def</span> <span style="color:#dcdcaa;">__init__</span>(self, language_model, tools, sampling_threshold=0.05, filtering_threshold=1.0):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.lm = language_model<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.tools = {tool.name: tool <span style="color:#569cd6;">for</span> tool <span style="color:#569cd6;">in</span> tools}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.Ï„_s = sampling_threshold<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.Ï„_f = filtering_threshold<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">def</span> <span style="color:#dcdcaa;">sample_api_calls</span>(self, text, tool_name, prompt_template):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Sample potential API calls for a given text and tool"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tool = self.tools[tool_name]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prompt = prompt_template.format(x=text)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#6a9955;"># Find positions where LM is likely to start API call</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidate_positions = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">for</span> i <span style="color:#569cd6;">in</span> range(len(text.split())):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefix = prompt + text[:i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p_api = self.lm.get_probability(<span style="color:#ce9178;">"[API]"</span>, prefix)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">if</span> p_api > self.Ï„_s:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidate_positions.append(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#6a9955;"># Sample API calls at candidate positions</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;api_calls = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">for</span> pos <span style="color:#569cd6;">in</span> candidate_positions[:5]:  <span style="color:#6a9955;"># Limit to top 5 positions</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefix = prompt + text[:pos] + <span style="color:#ce9178;">"[API]"</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">for</span> _ <span style="color:#569cd6;">in</span> range(5):  <span style="color:#6a9955;"># Sample 5 calls per position</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call_text = self.lm.sample_continuation(prefix, stop_token=<span style="color:#ce9178;">"[/API]"</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">if</span> call_text.startswith(<span style="color:#ce9178;">f"{tool_name}("</span>):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;api_calls.append((pos, call_text))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">return</span> api_calls<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">def</span> <span style="color:#dcdcaa;">filter_api_calls</span>(self, text, api_calls, tool_name):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Filter API calls based on perplexity reduction"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tool = self.tools[tool_name]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filtered_calls = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">for</span> pos, call_text <span style="color:#569cd6;">in</span> api_calls:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#6a9955;"># Extract query from call_text</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query = call_text.split(<span style="color:#ce9178;">"("</span>)[1].split(<span style="color:#ce9178;">")"</span>)[0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#6a9955;"># Execute API call</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = tool.call(query)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#6a9955;"># Calculate perplexity reduction</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_with_call = (<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text[:pos] + tool.format_result(query, result) + text[pos:]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_without_call = text<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L_with = self.lm.calculate_perplexity(text_with_call, start_pos=pos)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L_without = self.lm.calculate_perplexity(text_without_call, start_pos=pos)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">if</span> L_without - L_with > self.Ï„_f:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filtered_calls.append((pos, query, result))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">return</span> filtered_calls<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">def</span> <span style="color:#dcdcaa;">augment_dataset</span>(self, dataset):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Augment language modeling dataset with filtered API calls"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;augmented_data = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">for</span> text <span style="color:#569cd6;">in</span> dataset:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;augmented_text = text<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">for</span> tool_name <span style="color:#569cd6;">in</span> self.tools:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;api_calls = self.sample_api_calls(text, tool_name)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filtered_calls = self.filter_api_calls(text, api_calls, tool_name)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#6a9955;"># Insert filtered calls into text</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">for</span> pos, query, result <span style="color:#569cd6;">in</span> sorted(filtered_calls, reverse=True):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tool = self.tools[tool_name]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call_with_result = tool.format_result(query, result)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;augmented_text = augmented_text[:pos] + call_with_result + augmented_text[pos:]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;augmented_data.append(augmented_text)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#569cd6;">return</span> augmented_data<br>
        </div>
      </div>
    </div>
</section>
</body>
</html>
