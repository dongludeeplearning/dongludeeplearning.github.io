<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style>
  :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --panel2:#0c1430;
      --text:#e8ecff;
      --muted:#aeb7e6;
      --border:rgba(255,255,255,.10);
      --accent:#7aa2ff;
      --accent2:#8bffcf;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  }
  body {
    background: transparent;
    background-color: var(--bg);
    color: var(--text);
    font-family: var(--sans);
    margin: 0;
    padding: 16px;
    box-sizing: border-box;
  }
  ::-webkit-scrollbar { width: 8px; height: 8px; }
  ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
  ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
  ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }
</style>
<script>
function toggleLang(btn) {
  const container = btn.closest('div');
  const enElements = container.querySelectorAll('.lang-en');
  const zhElements = container.querySelectorAll('.lang-zh');

  enElements.forEach(el => {
    el.style.display = (el.style.display === 'none') ? 'block' : 'none';
  });

  zhElements.forEach(el => {
    el.style.display = (el.style.display === 'none') ? 'block' : 'none';
  });
}
function openLocalPdf(filename) {
  // ç›´æ¥æ‰“å¼€PDFæ–‡ä»¶
  window.open('pdfs/' + filename, '_blank');
}
function delLocalPdf(filename) {
  if (confirm('Delete local PDF file: ' + filename + '? Note: This requires server environment to actually delete files.')) {
    alert('Delete function needs to be implemented on the server side.');
  }
}
</script>
</head>
<body>
<section style="max-width:980px;margin:0 auto;">
    <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
      <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
      <div style="font-family:ui-monospace,Menlo,Consolas,monospace;color:rgba(232,236,255,.7);font-size:12px;">
        Paper Digest â€¢ ArXiv 2021
      </div>
      <h1 style="margin:6px 0 0;font-size:22px;line-height:1.25;">FAR Planner: Fast, Attemptable Route Planner using Dynamic Visibility Update</h1>
      <div style="margin-top:6px;color:rgba(232,236,255,.6);font-size:12px;line-height:1.5;">
        Fan Yang, Chao Cao, Hongbiao Zhu, Jean Oh, Ji Zhang<br>
        <span style="opacity:0.8">Carnegie Mellon University</span>
      </div>
      <div style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,.08);color:rgba(232,236,255,.75);font-size:13px;line-height:1.6;">
        <div class="lang-en">
            <b>One-Sentence Problem:</b> How can a visibility graph-based planner efficiently navigate robots through unknown environments with dynamic updates while maintaining fast replanning capabilities?
        </div>
        <div class="lang-zh" style="display:none">
            <b>ä¸€å¥è¯é—®é¢˜ï¼š</b>å¦‚ä½•ä½¿åŸºäºå¯è§æ€§å›¾çš„è§„åˆ’å™¨èƒ½å¤Ÿé€šè¿‡åŠ¨æ€æ›´æ–°é«˜æ•ˆåœ°åœ¨æœªçŸ¥ç¯å¢ƒä¸­å¯¼èˆªæœºå™¨äººï¼ŒåŒæ—¶ä¿æŒå¿«é€Ÿé‡è§„åˆ’èƒ½åŠ›ï¼Ÿ
        </div>
      </div>
    </div>

    <div style="display:grid;grid-template-columns:1fr;gap:14px;margin-top:14px;">
      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Contributionsï¼ˆè´¡çŒ®ï¼‰</h2>
        <ul style="margin:0;padding-left:18px;color:rgba(232,236,255,.80);line-height:1.65;">
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Two-Layered Visibility Graph Framework:</b> Incremental polygon extraction from obstacle edge points and dynamic visibility graph construction with local and global layers for efficient computation in unknown environments.</div>
            <div class="lang-zh" style="display:none"><b>ä¸¤å±‚å¯è§æ€§å›¾æ¡†æ¶ï¼š</b>ä»éšœç¢ç‰©è¾¹ç¼˜ç‚¹å¢é‡æå–å¤šè¾¹å½¢ï¼Œå¹¶åœ¨å±€éƒ¨å’Œå…¨å±€å±‚ä¸­æ„å»ºåŠ¨æ€å¯è§æ€§å›¾ï¼Œä»¥åœ¨æœªçŸ¥ç¯å¢ƒä¸­å®ç°é«˜æ•ˆè®¡ç®—ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Dynamic Visibility Updates:</b> Real-time visibility graph adjustments by expanding edges during navigation and removing occluded edges from newly observed obstacles, enabling fast replanning in changing environments.</div>
            <div class="lang-zh" style="display:none"><b>åŠ¨æ€å¯è§æ€§æ›´æ–°ï¼š</b>é€šè¿‡åœ¨å¯¼èˆªè¿‡ç¨‹ä¸­æ‰©å±•è¾¹å¹¶ä»æ–°è§‚å¯Ÿåˆ°çš„éšœç¢ç‰©ä¸­ç§»é™¤è¢«é®æŒ¡çš„è¾¹æ¥å®æ—¶è°ƒæ•´å¯è§æ€§å›¾ï¼Œä»è€Œåœ¨å˜åŒ–ç¯å¢ƒä¸­å®ç°å¿«é€Ÿé‡è§„åˆ’ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Attemptable Navigation:</b> Sequential route attempts in unknown environments by discovering layout on-the-fly, updating visibility graph, and performing fast replanning to reach goals.</div>
            <div class="lang-zh" style="display:none"><b>å¯å°è¯•å¯¼èˆªï¼š</b>é€šè¿‡å®æ—¶å‘ç°å¸ƒå±€ã€æ›´æ–°å¯è§æ€§å›¾å’Œæ‰§è¡Œå¿«é€Ÿé‡è§„åˆ’ï¼Œåœ¨æœªçŸ¥ç¯å¢ƒä¸­æŒ‰é¡ºåºå°è¯•è·¯çº¿ä»¥åˆ°è¾¾ç›®æ ‡ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Comprehensive Benchmarking:</b> Extensive evaluation against state-of-the-art planners (A*, D* Lite, RRT*, BIT*, SPARS) showing 12-47% travel time reduction in unknown environments with low computational cost.</div>
            <div class="lang-zh" style="display:none"><b>å…¨é¢åŸºå‡†æµ‹è¯•ï¼š</b>å¯¹æœ€å…ˆè¿›è§„åˆ’å™¨ï¼ˆA*ã€D* Liteã€RRT*ã€BIT*ã€SPARSï¼‰çš„å¹¿æ³›è¯„ä¼°æ˜¾ç¤ºï¼Œåœ¨æœªçŸ¥ç¯å¢ƒä¸­æ—…è¡Œæ—¶é—´å‡å°‘12-47%ï¼Œè®¡ç®—æˆæœ¬ä½ã€‚</div>
          </li>
        </ul>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Challengesï¼ˆæŒ‘æˆ˜ï¼‰</h2>
        <ul style="margin:0;padding-left:18px;color:rgba(232,236,255,.80);line-height:1.65;">
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Visibility Graph Computational Complexity:</b> Traditional visibility graph construction has O(nÂ² log n) complexity and requires polygonal world representation, making it unsuitable for real-time robotic applications in unstructured environments.</div>
            <div class="lang-zh" style="display:none"><b>å¯è§æ€§å›¾è®¡ç®—å¤æ‚åº¦ï¼š</b>ä¼ ç»Ÿå¯è§æ€§å›¾æ„å»ºå…·æœ‰O(nÂ² log n)å¤æ‚åº¦å¹¶éœ€è¦å¤šè¾¹å½¢ä¸–ç•Œè¡¨ç¤ºï¼Œä½¿å…¶ä¸é€‚åˆéç»“æ„åŒ–ç¯å¢ƒä¸­å®æ—¶æœºå™¨äººåº”ç”¨ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Dynamic Environment Updates:</b> Handling newly observed obstacles and changing environment representations requires efficient graph modifications without complete reconstruction for real-time replanning.</div>
            <div class="lang-zh" style="display:none"><b>åŠ¨æ€ç¯å¢ƒæ›´æ–°ï¼š</b>å¤„ç†æ–°è§‚å¯Ÿåˆ°çš„éšœç¢ç‰©å’Œå˜åŒ–çš„ç¯å¢ƒè¡¨ç¤ºéœ€è¦é«˜æ•ˆçš„å›¾ä¿®æ”¹ï¼Œè€Œæ— éœ€å®Œå…¨é‡å»ºä»¥è¿›è¡Œå®æ—¶é‡è§„åˆ’ã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>Unknown Environment Navigation:</b> Sequential route attempts in unexplored spaces require balancing exploration with goal-directed navigation while maintaining computational efficiency.</div>
            <div class="lang-zh" style="display:none"><b>æœªçŸ¥ç¯å¢ƒå¯¼èˆªï¼š</b>åœ¨æœªæ¢ç´¢ç©ºé—´ä¸­æŒ‰é¡ºåºå°è¯•è·¯çº¿éœ€è¦åœ¨ä¿æŒè®¡ç®—æ•ˆç‡çš„åŒæ—¶å¹³è¡¡æ¢ç´¢ä¸ç›®æ ‡å¯¼å‘å¯¼èˆªã€‚</div>
          </li>
          <li style="margin-bottom:8px;">
            <div class="lang-en"><b>3D Multi-Layer Representation:</b> Extending visibility graph to 3D environments for aerial vehicles requires multi-layer polygonal representation and cross-layer visibility edge connections.</div>
            <div class="lang-zh" style="display:none"><b>3Då¤šå±‚è¡¨ç¤ºï¼š</b>å°†å¯è§æ€§å›¾æ‰©å±•åˆ°3Dç¯å¢ƒä»¥ç”¨äºç©ºä¸­è½¦è¾†éœ€è¦å¤šå±‚å¤šè¾¹å½¢è¡¨ç¤ºå’Œè·¨å±‚å¯è§æ€§è¾¹è¿æ¥ã€‚</div>
          </li>
        </ul>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Methodï¼ˆæ–¹æ³•ï¼‰</h2>
        <div style="margin:0;padding-left:18px;color:rgba(232,236,255,.80);line-height:1.65;">
          <div class="lang-en">
            <p>The FAR Planner introduces a visibility graph-based framework for efficient navigation in unknown environments:</p>
            <ol style="margin:8px 0;">
                <li style="margin-bottom:6px;"><b>Obstacle Polygon Extraction:</b> Converts LiDAR point clouds into binary images, applies inflation for vehicle size, uses image processing to extract enclosed polygons with dense vertices representing obstacle contours.</li>
                <li style="margin-bottom:6px;"><b>Two-Layered Visibility Graph:</b> Maintains local layer (40mÃ—40m) around robot for incremental updates and global layer covering observed environment, merging local updates into global graph at low computational cost.</li>
                <li style="margin-bottom:6px;"><b>Dynamic Graph Updates:</b> Expands visibility edges during navigation, removes edges occluded by newly observed obstacles, and handles dynamic obstacles by disconnecting/reconnecting blocked edges.</li>
                <li style="margin-bottom:6px;"><b>Path Planning on Graph:</b> Performs breadth-first search on visibility graph to find shortest paths, with fast replanning (<10ms) by reusing graph structure and updating only affected regions.</li>
                <li style="margin-bottom:6px;"><b>3D Multi-Layer Extension:</b> Models aerial environments as horizontal slices with multi-layer polygons, connects visibility edges across layers for 3D navigation planning.</li>
            </ol>
          </div>
          <div class="lang-zh" style="display: none;">
            <p>FAR Plannerå¼•å…¥äº†ä¸€ç§åŸºäºå¯è§æ€§å›¾çš„æ¡†æ¶ï¼Œç”¨äºåœ¨æœªçŸ¥ç¯å¢ƒä¸­é«˜æ•ˆå¯¼èˆªï¼š</p>
            <ol style="margin:8px 0;">
                <li style="margin-bottom:6px;"><b>éšœç¢ç‰©å¤šè¾¹å½¢æå–ï¼š</b>å°†LiDARç‚¹äº‘è½¬æ¢ä¸ºäºŒè¿›åˆ¶å›¾åƒï¼Œä¸ºè½¦è¾†å°ºå¯¸åº”ç”¨è†¨èƒ€ï¼Œä½¿ç”¨å›¾åƒå¤„ç†æå–å…·æœ‰å¯†é›†é¡¶ç‚¹çš„å°é—­å¤šè¾¹å½¢ï¼Œè¡¨ç¤ºéšœç¢ç‰©è½®å»“ã€‚</li>
                <li style="margin-bottom:6px;"><b>ä¸¤å±‚å¯è§æ€§å›¾ï¼š</b>ç»´æŠ¤æœºå™¨äººå‘¨å›´çš„å±€éƒ¨å±‚ï¼ˆ40mÃ—40mï¼‰ç”¨äºå¢é‡æ›´æ–°å’Œè¦†ç›–è§‚å¯Ÿç¯å¢ƒçš„å…¨å±€å±‚ï¼Œä»¥ä½è®¡ç®—æˆæœ¬å°†å±€éƒ¨æ›´æ–°åˆå¹¶åˆ°å…¨å±€å›¾ä¸­ã€‚</li>
                <li style="margin-bottom:6px;"><b>åŠ¨æ€å›¾æ›´æ–°ï¼š</b>åœ¨å¯¼èˆªè¿‡ç¨‹ä¸­æ‰©å±•å¯è§æ€§è¾¹ï¼Œç§»é™¤è¢«æ–°è§‚å¯Ÿåˆ°çš„éšœç¢ç‰©é®æŒ¡çš„è¾¹ï¼Œå¹¶é€šè¿‡æ–­å¼€/é‡æ–°è¿æ¥è¢«é˜»å¡çš„è¾¹æ¥å¤„ç†åŠ¨æ€éšœç¢ç‰©ã€‚</li>
                <li style="margin-bottom:6px;"><b>å›¾ä¸Šè·¯å¾„è§„åˆ’ï¼š</b>å¯¹å¯è§æ€§å›¾æ‰§è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ä»¥æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼Œé€šè¿‡é‡ç”¨å›¾ç»“æ„å’Œä»…æ›´æ–°å—å½±å“åŒºåŸŸï¼Œå®ç°å¿«é€Ÿé‡è§„åˆ’ï¼ˆ<10msï¼‰ã€‚</li>
                <li style="margin-bottom:6px;"><b>3Då¤šå±‚æ‰©å±•ï¼š</b>å°†ç©ºä¸­ç¯å¢ƒå»ºæ¨¡ä¸ºå…·æœ‰å¤šå±‚å¤šè¾¹å½¢çš„æ°´å¹³åˆ‡ç‰‡ï¼Œè·¨å±‚è¿æ¥å¯è§æ€§è¾¹ä»¥è¿›è¡Œ3Då¯¼èˆªè§„åˆ’ã€‚</li>
            </ol>
          </div>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <h2 style="margin:0 0 8px;font-size:16px;">Intro Figureï¼ˆç¤ºä¾‹ï¼‰</h2>
        <div style="border-radius:14px; overflow:hidden;">
             <img src="Figures/far_planner_intro.png" style="width:100%; height:auto; display:block; border-radius:8px;" alt="Intro Figure" />
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10)">
        <h2 style="margin:0 0 8px;font-size:16px;">Overview Figureï¼ˆç¤ºæ„å›¾ï¼‰</h2>
        <div style="border:1px dashed rgba(255,255,255,.18);border-radius:14px;padding:16px;color:rgba(232,236,255,.65);line-height:1.6;">
          <img src="Figures/far_planner_overview01.png" style="width:100%; height:auto; display:block; border-radius:8px;" alt="Intro Figure" />
          <img src="Figures/far_planner_overview02.png" style="width:100%; height:auto; display:block; border-radius:8px;" alt="Intro Figure" />

            <div style="margin-top:12px; display:flex; gap:10px; justify-content:flex-end;">
                 <button onclick="openLocalPdf('arxiv_far_planner.pdf')" style="background:rgba(139,255,207,0.1); border:1px solid rgba(139,255,207,0.3); color:#8bffcf; padding:6px 12px; border-radius:8px; cursor:pointer; font-size:12px;">ğŸ“‚ Open Local PDF</button>
                 <button onclick="delLocalPdf('arxiv_far_planner.pdf')" style="background:rgba(255,100,100,0.1); border:1px solid rgba(255,100,100,0.3); color:#ff6464; padding:6px 12px; border-radius:8px; cursor:pointer; font-size:12px;">ğŸ—‘ï¸ Del Local PDF</button>
            </div>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Discussionï¼ˆè®¨è®ºï¼‰</h2>
        <h3 style="margin:12px 0 6px;font-size:14px;color:#8bffcf;">Why it Works?</h3>
        <div style="color:rgba(232,236,255,.80);line-height:1.65;">
          <div class="lang-en">
            <p>The FAR Planner's effectiveness in unknown environment navigation stems from its innovative visibility graph approach:</p>
            <ul style="margin:8px 0;">
                <li style="margin-bottom:6px;"><b>Incremental Graph Construction:</b> Two-layered framework distributes computation evenly across frames by updating only local regions, achieving low computational cost (âˆ¼20% CPU usage) while maintaining global consistency.</li>
                <li style="margin-bottom:6px;"><b>Line-of-Sight Efficiency:</b> Visibility graph leverages sparse edge connections between obstacles, avoiding dense sampling in unknown spaces and enabling fast path finding in partially observed environments.</li>
                <li style="margin-bottom:6px;"><b>Dynamic Adaptability:</b> Graph modifications handle both static environment discovery and dynamic obstacle avoidance, with edge removal/addition operations that preserve graph structure for efficient replanning.</li>
                <li style="margin-bottom:6px;"><b>Attemptable Exploration:</b> Sequential route testing in unknown spaces allows progressive environment discovery without requiring complete prior knowledge, making it suitable for real-world robotic applications.</li>
                <li style="margin-bottom:6px;"><b>Scalable Performance:</b> Sub-linear complexity growth with environment size and consistent low-latency planning (<10ms) enables deployment on resource-constrained robotic platforms for real-time navigation.</li>
            </ul>
          </div>
          <div class="lang-zh" style="display:none">
            <p>FAR Planneråœ¨æœªçŸ¥ç¯å¢ƒå¯¼èˆªä¸­çš„æœ‰æ•ˆæ€§æºäºå…¶åˆ›æ–°çš„å¯è§æ€§å›¾æ–¹æ³•ï¼š</p>
            <ul style="margin:8px 0;">
                <li style="margin-bottom:6px;"><b>å¢é‡å›¾æ„å»ºï¼š</b>ä¸¤å±‚æ¡†æ¶é€šè¿‡ä»…æ›´æ–°å±€éƒ¨åŒºåŸŸåœ¨å¸§é—´å‡åŒ€åˆ†é…è®¡ç®—ï¼Œå®ç°ä½è®¡ç®—æˆæœ¬ï¼ˆçº¦20% CPUä½¿ç”¨ç‡ï¼‰åŒæ—¶ä¿æŒå…¨å±€ä¸€è‡´æ€§ã€‚</li>
                <li style="margin-bottom:6px;"><b>è§†çº¿æ•ˆç‡ï¼š</b>å¯è§æ€§å›¾åˆ©ç”¨éšœç¢ç‰©ä¹‹é—´çš„ç¨€ç–è¾¹è¿æ¥ï¼Œé¿å…åœ¨æœªçŸ¥ç©ºé—´ä¸­çš„å¯†é›†é‡‡æ ·ï¼Œå¹¶åœ¨éƒ¨åˆ†è§‚å¯Ÿç¯å¢ƒä¸­å®ç°å¿«é€Ÿè·¯å¾„æŸ¥æ‰¾ã€‚</li>
                <li style="margin-bottom:6px;"><b>åŠ¨æ€é€‚åº”æ€§ï¼š</b>å›¾ä¿®æ”¹åŒæ—¶å¤„ç†é™æ€ç¯å¢ƒå‘ç°å’ŒåŠ¨æ€éšœç¢ç‰©é¿å…ï¼Œè¾¹ç§»é™¤/æ·»åŠ æ“ä½œä¿ç•™å›¾ç»“æ„ä»¥å®ç°é«˜æ•ˆé‡è§„åˆ’ã€‚</li>
                <li style="margin-bottom:6px;"><b>å¯å°è¯•æ¢ç´¢ï¼š</b>åœ¨æœªçŸ¥ç©ºé—´ä¸­çš„é¡ºåºè·¯çº¿æµ‹è¯•å…è®¸æ¸è¿›ç¯å¢ƒå‘ç°ï¼Œè€Œæ— éœ€å®Œæ•´å…ˆéªŒçŸ¥è¯†ï¼Œä½¿å…¶é€‚åˆçœŸå®ä¸–ç•Œæœºå™¨äººåº”ç”¨ã€‚</li>
                <li style="margin-bottom:6px;"><b>å¯æ‰©å±•æ€§èƒ½ï¼š</b>éšç€ç¯å¢ƒå¤§å°çš„æ¬¡çº¿æ€§å¤æ‚åº¦å¢é•¿å’Œä¸€è‡´çš„ä½å»¶è¿Ÿè§„åˆ’ï¼ˆ<10msï¼‰èƒ½å¤Ÿåœ¨èµ„æºå—é™çš„æœºå™¨äººå¹³å°ä¸Šè¿›è¡Œå®æ—¶å¯¼èˆªéƒ¨ç½²ã€‚</li>
            </ul>
          </div>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10); position: relative;">
        <button onclick="toggleLang(this)" style="position: absolute; top: 16px; right: 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #aeb7e6; padding: 4px 10px; border-radius: 8px; cursor: pointer; font-size: 12px;">ä¸­ / En</button>
        <h2 style="margin:0 0 8px;font-size:16px;">Conclusionï¼ˆç»“è®ºï¼‰</h2>
        <div style="color:rgba(232,236,255,.80);line-height:1.65;">
          <div class="lang-en">
            <p>This work reintroduces visibility graph-based planning as a powerful solution for robotic navigation in unknown environments, overcoming traditional computational barriers through a two-layered dynamic update framework. The FAR Planner demonstrates superior performance compared to state-of-the-art search-based (A*, D* Lite) and sampling-based (RRT*, BIT*, SPARS) methods, achieving up to 47% reduction in travel time while maintaining low computational overhead. By incrementally constructing and updating visibility graphs from sensor data, the method enables attemptable navigation that progressively discovers environment layouts and efficiently replans routes. Experimental validation across simulated indoor, outdoor campus, and tunnel environments, as well as real-world ground vehicle deployments, confirms the approach's robustness and scalability. The framework's extension to 3D multi-layer representations further enables aerial vehicle navigation. This work establishes visibility graph planning as a practical and efficient alternative for autonomous robotic systems operating in complex, unknown environments.</p>
          </div>
          <div class="lang-zh" style="display:none">
            <p>è¿™é¡¹å·¥ä½œé‡æ–°å¼•å…¥åŸºäºå¯è§æ€§å›¾çš„è§„åˆ’ä½œä¸ºæœªçŸ¥ç¯å¢ƒä¸­æœºå™¨äººå¯¼èˆªçš„å¼ºå¤§è§£å†³æ–¹æ¡ˆï¼Œé€šè¿‡ä¸¤å±‚åŠ¨æ€æ›´æ–°æ¡†æ¶å…‹æœä¼ ç»Ÿè®¡ç®—éšœç¢ã€‚FAR Plannerå±•ç¤ºäº†ä¼˜äºæœ€å…ˆè¿›æœç´¢åŸºï¼ˆA*ã€D* Liteï¼‰å’Œé‡‡æ ·åŸºï¼ˆRRT*ã€BIT*ã€SPARSï¼‰æ–¹æ³•çš„å“è¶Šæ€§èƒ½ï¼Œåœ¨ä¿æŒä½è®¡ç®—å¼€é”€çš„åŒæ—¶å®ç°æ—…è¡Œæ—¶é—´å‡å°‘é«˜è¾¾47%ã€‚é€šè¿‡ä»ä¼ æ„Ÿå™¨æ•°æ®å¢é‡æ„å»ºå’Œæ›´æ–°å¯è§æ€§å›¾ï¼Œè¯¥æ–¹æ³•å®ç°äº†å¯å°è¯•å¯¼èˆªï¼Œèƒ½å¤Ÿæ¸è¿›å‘ç°ç¯å¢ƒå¸ƒå±€å¹¶é«˜æ•ˆé‡è§„åˆ’è·¯çº¿ã€‚å¯¹æ¨¡æ‹Ÿå®¤å†…ã€å¤–æ ¡å›­å’Œéš§é“ç¯å¢ƒä»¥åŠçœŸå®ä¸–ç•Œåœ°é¢è½¦è¾†éƒ¨ç½²çš„å®éªŒéªŒè¯è¯å®äº†è¯¥æ–¹æ³•çš„é²æ£’æ€§å’Œå¯æ‰©å±•æ€§ã€‚è¯¥æ¡†æ¶æ‰©å±•åˆ°3Då¤šå±‚è¡¨ç¤ºè¿›ä¸€æ­¥å®ç°äº†ç©ºä¸­è½¦è¾†å¯¼èˆªã€‚è¿™é¡¹å·¥ä½œå°†å¯è§æ€§å›¾è§„åˆ’ç¡®ç«‹ä¸ºå¤æ‚æœªçŸ¥ç¯å¢ƒä¸­è‡ªä¸»æœºå™¨äººç³»ç»Ÿçš„å®ç”¨ä¸”é«˜æ•ˆçš„æ›¿ä»£æ–¹æ¡ˆã€‚</p>
          </div>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10)">
        <h2 style="margin:0 0 8px;font-size:16px;">Official Code</h2>
        <div style="color:rgba(232,236,255,.80);line-height:1.65;">
          <p><b>ArXiv:</b> <a href="https://arxiv.org/abs/2110.09460" style="color:#8bffcf;">2110.09460</a></p>
          <p><b>GitHub:</b> <a href="https://github.com/MichaelFYang/far_planner" style="color:#8bffcf;">https://github.com/MichaelFYang/far_planner</a></p>
          <p><b>Development Environment:</b> <a href="https://www.cmu-exploration.com/" style="color:#8bffcf;">www.cmu-exploration.com</a></p>
        </div>
      </div>

      <div style="padding:16px;border:1px solid rgba(255,255,255,.10);border-radius:16px;background:rgba(0,0,0,.10)">
        <h2 style="margin:0 0 8px;font-size:16px;">Core Code Implementationï¼ˆæ ¸å¿ƒä»£ç å®ç°ï¼‰</h2>
        <div style="background:rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.1); border-radius:8px; padding:12px; font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; color:#8bffcf; margin:8px 0; overflow-x:auto;">
import numpy as np<br>
import cv2<br>
from collections import deque<br>
<br>
// FAR Planner: Fast, Attemptable Route Planner<br>
class FARPlanner:<br>
&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self, local_range=40.0, resolution=0.2):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.local_range = local_range<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.resolution = resolution<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.global_polygons = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.global_edges = set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.robot_pos = None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.goal_pos = None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def update_map(self, sensor_points, robot_pos):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Update visibility graph with new sensor data"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.robot_pos = robot_pos<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Extract local polygons from sensor points<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_polygons = self._extract_polygons(sensor_points, robot_pos)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Build local visibility graph<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_edges = self._build_local_visibility_graph(local_polygons)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Merge with global graph<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._merge_graphs(local_polygons, local_edges)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def plan_path(self, goal_pos):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Find shortest path using visibility graph"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.goal_pos = goal_pos<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Add start and goal vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices = self._get_all_vertices() + [self.robot_pos, goal_pos]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges = self._get_all_edges()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Add connections from start/goal to visible vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_edges = self._connect_to_vertices(self.robot_pos, vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goal_edges = self._connect_to_vertices(goal_pos, vertices)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.update(start_edges)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.update(goal_edges)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# BFS for shortest path<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self._bfs_shortest_path(vertices, edges)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def _extract_polygons(self, sensor_points, robot_pos):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Extract polygons from sensor points using image processing"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create binary image<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img_size = int(2 * self.local_range / self.resolution)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binary_img = np.zeros((img_size, img_size), dtype=np.uint8)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Project points to image (simplified)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for point in sensor_points:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_pixel = int((point[0] - robot_pos[0] + self.local_range) / self.resolution)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_pixel = int((point[1] - robot_pos[1] + self.local_range) / self.resolution)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if 0 <= x_pixel < img_size and 0 <= y_pixel < img_size:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binary_img[y_pixel, x_pixel] = 255<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Apply morphological operations and extract contours<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binary_img = cv2.morphologyEx(binary_img, cv2.MORPH_CLOSE, kernel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contours, _ = cv2.findContours(binary_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Convert to polygons<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polygons = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for contour in contours:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cv2.contourArea(contour) > 10:  # Filter small contours<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polygon = contour.reshape(-1, 2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Convert back to world coordinates<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polygon_world = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for px, py in polygon:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_world = (px * self.resolution) - self.local_range + robot_pos[0]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_world = (py * self.resolution) - self.local_range + robot_pos[1]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polygon_world.append([x_world, y_world])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polygons.append(np.array(polygon_world))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return polygons<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def _build_local_visibility_graph(self, polygons):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Build partially reduced visibility graph"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges = set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for polygon in polygons:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices.extend(polygon)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Connect vertices with visibility edges<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i, v1 in enumerate(vertices):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j, v2 in enumerate(vertices):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if i != j and self._is_visible(v1, v2, polygons):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_length = np.linalg.norm(v2 - v1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if edge_length > 2.0:  # Keep longer edges that pass around<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.add((tuple(v1), tuple(v2)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return edges<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def _is_visible(self, v1, v2, polygons):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Check if line segment between v1 and v2 is not blocked"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Simplified visibility check - in practice would need proper polygon intersection<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True  # Placeholder<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def _merge_graphs(self, local_polygons, local_edges):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Merge local graph with global graph"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.global_polygons.extend(local_polygons)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.global_edges.update(local_edges)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def _get_all_vertices(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Get all vertices from global polygons"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for polygon in self.global_polygons:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices.extend(polygon)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return vertices<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def _get_all_edges(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self.global_edges<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def _connect_to_vertices(self, point, vertices):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Connect point to all visible vertices"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges = set()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for vertex in vertices:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self._is_visible(point, np.array(vertex), self.global_polygons):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.add((tuple(point), vertex))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return edges<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def _bfs_shortest_path(self, vertices, edges):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Find shortest path using BFS on visibility graph"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not vertices or self.robot_pos is None or self.goal_pos is None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create adjacency list<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adj_list = {tuple(v): [] for v in vertices}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for edge in edges:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1, v2 = edge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adj_list[v1].append(v2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adj_list[v2].append(v1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# BFS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue = deque([tuple(self.robot_pos)])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;came_from = {tuple(self.robot_pos): None}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while queue:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current = queue.popleft()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if np.allclose(np.array(current), self.goal_pos, atol=0.1):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for neighbor in adj_list[current]:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor not in came_from:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;came_from[neighbor] = current<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.append(neighbor)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Reconstruct path<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current = tuple(self.goal_pos)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while current is not None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.append(current)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current = came_from.get(current)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.reverse()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return path<br>
        </div>
      </div>
    </div>
</section>
</body>
</html>
